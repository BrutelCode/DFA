#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// Συνάρτηση για τον έλεγχο της εισόδου του χρήστη
int CheckString(char *string,char *alphabet);


	int main()
	{
		FILE *fp; // Pointer Αρχείου
   		int states; // Σύνολο Καταστάσεων
   		int i = 1; // Γραμμή διαβάσματος αρχείου
   		int k = 0; // Counter για την αποθήκευση στοιχείων στους πίνακες cs,tr,nw
  		int trans = 0; // Σύνολο μεταθέσεων
  		int fl_counter = 0; // Counter για το υπολογισμό των γραμμάτων της αλφαβητου
		char line[256]; // Πίνακας για αποθήκευση στοιχείων κατά το διάβασμα αρχείου
  		char start; // Αρχική Κατάσταση
  		char *alphabet; //Δημιουργούμε έναν πίνακα όπου θα κρατάμε την αλφάβητο
  		char *final; // Τελικές καταστάσεις
  		char input[30]; // Είσοδος του χρήστη
  		
		//cs = Τρέχουσα κατάσταση(1η στήλη),tr = Τιμή μετάβασης(2η στήλη),nw = Νέα κατάσταση(3η στήλη)
		char *cs,*tr,*nw;
  		
  		// ’νοιγμα αρχείου
   		fp = fopen("C:\\Users\\Christos\\Desktop\\dfa.txt","r");
   		
   		//Έλεγχος για τυχόν πρόβλημα κατά το άνοιγμα του αρχείου
   		if(fp == NULL)
   		{
   			perror("Error opening file");
      		return -1;
		}
   		
	//Διάβασμα αρχείου γραμμή-γραμμή
    while (fgets(line, sizeof(line), fp))
	 {

 		if(i == 1) //Διάβασμα 1ης γραμμής - Καταστάσεις αυτόματου
      	{
      		states = atoi(line); // Μετατροπή char στοιχείο σε integer
      		if(states >= 10) // Έλεγχος για το σύνολο των καταστάσεων
      		{
      			printf("The automatic must have under ten(<10) states!");
      			return 1;
			}
		}
 		
 		if(i == 2) //Διάβασμα 2ης γραμμής - Αλφάβητο αυτόματου
      	{
      		int cnt = 0; //Αρχικοποίηση μετρητή
      		int j = 0; //Αρχικοποίηση μεταβλητής για προσπέλαση του πίνακα
      		
      		// Όσο διαφορετικό της αλλαγής γραμμής('\n') τρέχουμε τον πίνακα
      		while(line[j] != '\n') 
      		{
				if(line[j] != ' ') //Αν το στοιχείο διαφορετικό του κενού(' ')
				{
					cnt++; //Αυξάνουμε τον μετρητή
					fl_counter++; //Counter για το υπολογισμό των γραμμάτων της αλφαβητου
				}	
				j++; // Αύξηση για προσπέλαση επόμενου στοιχείου του πίνακα	
			}
			
			alphabet = (char *)malloc(cnt * sizeof(char)); //Δεσμεύουμε δυναμικά χώρο για την αλφάβητο
			
			j=0; cnt = 0;
			// Όσο διαφορετικό της αλλαγής γραμμής('\n') τρέχουμε τον πίνακα
      		while(line[j] != '\n') 
      		{
			  	if(line[j] != ' ') //Αν το στοιχείο διαφορετικό του κενού(' ')
					alphabet[cnt++] = line[j]; // Εκχωρούμε τα στοιχεία της αλφαβήτου στον πίνακα	
				j++; // Αύξηση για προσπέλαση επόμενου στοιχείου του πίνακα	
			}
						
			if(cnt >= 10) // Έλεγχος για το πλήθος συμβόλων 
			{
				printf("The alphabet must have under ten(<10) different symbols!");
      			return 2;
			}
			
			trans = states * fl_counter; // Σύνολο των καταστάσεων
    		
			cs = (char *)malloc(trans * sizeof(char)); //Δεσμεύουμε δυναμικά χώρο για τις τρέχουσες καταστάσεις (1η στήλη)
    		tr = (char *)malloc(trans * sizeof(char)); //Δεσμεύουμε δυναμικά χώρο για τις τιμές μετάβασεις (2η στήλη)
    		nw = (char *)malloc(trans * sizeof(char)); //Δεσμεύουμε δυναμικά χώρο για τις νέες καταστάσεις (3η στήλη)
		}
      	
      	if(i==3) //Διάβασμα 3ης γραμμής - Αρχική κατάσταση
      		start = line[0]; // Αποθηκέυουμε την αρχική κατάσταση
 	
 		if(i==4) //Διάβασμα 4ης γραμμής - Τελικές καταστάσεις
 		{
 			
 			int cnt = 0; //Αρχικοποίηση μετρητή
      		int j = 0; //Αρχικοποίηση μεταβλητής για προσπέλαση του πίνακα
      		
      		// Όσο διαφορετικό της αλλαγής γραμμής('\n') τρέχουμε τον πίνακα
      		while(line[j] != '\n')
      		{	
				if(line[j] != ' ')
				{ cnt++; } //Αυξάνουμε τον μετρητή
				
				j++; // Αύξηση για προσπέλαση επόμενου στοιχείου του πίνακα			
			}
 			
 			// Δεσμεύουμε μνήμη δυναμικά με βάση το πλήθος των τελικών καταστάσεων 
			final = (char *)malloc(cnt * sizeof(char));
			
			int k=0; j=0; //Αρχικοποιήση μεταβλητών
			
			// Όσο διαφορετικό της αλλαγής γραμμής('\n') τρέχουμε τον πίνακα
			while(line[j] != '\n') 
      		{
				if(line[j] != ' ')
				{ final[k++] = line[j]; } //Εκχωρούμε σε πίνακα τις τελικές καταστάσεις
				
				j++; // Αύξηση για προσπέλαση επόμενου στοιχείου του πίνακα		
			}
		}
 
	 
	 	// Στον παρακάτω έλεγχο διαβάζουμε όλες τις γραμμές απο την 4η γραμμή και μετά,
	 	// και αποθηκεύουμε τα στοιχεία αντίστοιχα στους 3 πίνακες(cs,tr,nw)
 		if(i > 4)
 		{	
			int j = 0;
 			while(line[j] != '\n') 
      		{
				if(line[j] != ' ') //Αν το στοιχείο διαφορετικό του κενού(' ')
				{
					if(j == 0) //Εάν βρισκόμαστε στο 1ο στοιχείο
						cs[k] = line[j]; //Αποθηκέυουμε το στοιχείο για τις τρέχουσες καταστάσεις
					if(j == 2) //Εάν βρισκόμαστε στο 2ο στοιχείο 
						tr[k] = line[j]; //Αποθηκέυουμε το στοιχείο για τις τιμές μετάβασεις
					if(j == 4) //Εάν βρισκόμαστε στο 3ο στοιχείο 
						nw[k] = line[j]; //Αποθηκέυουμε το στοιχείο για τις νέες καταστάστεις				
				}
				
					//Εάν βρεθούμε στην τελευταία γραμμή του αρχείο και τελιώσουμε την εκχώρηση κάνουμε break
					if(trans+4 == i && j == 4)
					break;
				
				j++; // Αύξηση για προσπέλαση επόμενου στοιχείου του πίνακα	line
			}
			
			k++; //Αύξηση μετρήτη για τους πίνακες cs,tr,nw ώστε να αυξάνονται παράλληλα
		}

		i++; // Μετρήτής με βάση την αλλαγή γραμμής κατά το διάβασμα του αρχείου
    }



	char ch;
	do{
	fflush(stdin); // Καθαρίζουμε το buffer
	
	//Διαβάζουμε την λέξη εισόδου απο τον χρήστη
    printf("Give the input:");
    fgets(input,30,stdin);

    
    // Ελέγχουμε αν η συμβολοσειρά εισόδου είναι αποδεκτή
    // σύμφωνα με το αλφάβητο
	if(CheckString(input,alphabet) == 0)
	  {
			printf("The input is wrong!");
			return 1;		
	  }
	  
    
    int length_in = strlen(input); //Μήκος εισόδου
    char final_state = start; // Αρχικοποιούμε την τελική κατάσταση με την αρχική κατάσταση
    int flag = 0; // flag για έλεγχο
    
    
    //Τρέχουμε ένα loop με βάση το μήκος εισόδου
    for(i=0;i<length_in-1;i++)
	{
		//Αρχικοποιήση μεταβλητών
		int j = 0;
		flag = 0;
		
		/* Τρέχουμε ένα loop με βάση το σύνολο των καταστάσεων, κάθε φορά που
		βρίσκουμαι την κατάσταση που χρειαζόμαστε για να γίνει η μετάβαση
		ορίζουμε το flag = 1 ώστε μετά το τον έλεγxo, να κάνουμε έναν
		έλεγχο αν το flag == 1 και τότε κάνουμε break αφού έχουμε ήδη βρει την
		κατάσταση που χρειαζόμαστε και συνεχίζουμε με το επόμενο γράμμα εισόδου */
		for(j=0;j<trans;j++)
		{
			if(final_state == cs[j] && input[i] == tr[j])
			{
				//printf("final_state: %c == cs[j]: %c\n",final_state,cs[j]);
				//printf("input:       %c == tr[j]: %c\n",input[i],tr[j]);
				printf("INPUT -> %c\nCURRENT_STATE -> q%c\n",input[i],final_state);
				final_state = nw[j];
				printf("NEW_STATE    -> 'q%c'\n\n",final_state);
				flag = 1;
			}
			
			if(flag==1)
			break;
		}		
	}
	
	fflush(stdin); // Καθαρίζουμε το buffer
	
	flag = 0; //Αρχικοποιούμε το flag
	
	/* Τρέχουμε ένα loop με το οποίο κοιτάμε όλες τις τελικές καταστάσεις
	 και συγκρίνουμε την κατάσταση που πήραμε απο την είσοδο ώστε να
	 δούμε αν είναι αποδεκτή τελική κατάσταση*/
	for(i=0;i<strlen(final);i++)
	{
		if(final_state == final[i])
		flag = 1;	
	}    
	
	//Εαν είναι αποδεκτή κατάσταση 
	if(flag == 1)
	{
		printf("--------------------------");
		printf("\nThe Input is acceptable!\n");
		printf("The Final State is q%c\n",final_state);
		printf("--------------------------");
	}
	else
	{
		printf("------------------------------");
		printf("\nThe Input is NOT acceptable!\n");
		printf("The Final State is q%c\n",final_state);
		printf("------------------------------");
	}
	
	//Ρωτάμε τον χρήστη αν θέλει να συνεχίσει ώστε τρέξει με νέα είσοδο
	printf ("\nDo you want to continue y/n: ");
	ch = getchar();
	system("cls");
	}while(ch == 'y' || ch == 'Y');
    
	// Αποδεσμεύουμε την μνήμη που χρησιμοποιήσαμε
    free(final);
    free(alphabet);
    free(cs);
    free(tr);
    free(nw);
    
    fclose(fp); //Κλείνουμε το αρχείο
    
	return 0;
}


	/*Συνάρτηση με την οποία κοιτάζουμε αν η είσοδος του χρήστη
	είναι σωστή με βάση το αλφάβητο του dfa */
	int CheckString(char *string,char *alphabet)
	{
		int i = 0, j = 0; //Counter πινάκων
		int flag = 0; // flag ώστε να τσεκάρουμε αν το string εμπεριέχεται στο αλφάβητο
		int s1 = strlen(string); // Μήκος Εισόδου
		int s2 = strlen(alphabet); // Μήκος Αλφαβήτου
		    	
		//Τρέχουμε ένα loop για κάθε γράμμα της εισόδου
		for(i=0;i<s1-1;i++)
    	{
    		flag = 0; //Αρχικοποιούμε με 0 κάθε φορά 
    		// Για κάθε γράμμα εισόδου ελέγχουμε όλα τα γράμματα τις αλφάβητου
    		for(j=0; j<s2; j++)
    		{	
    			if(string[i] == alphabet[j]) //Εάν το γράμμα εισόδου εμπεριέχεται στο αλφάβητο
    			flag = 1; //Αρχικοποιούμε το flag με 1	
			}
			
			if (flag == 0) //Εάν το γράμμα εισόδου ΔΕΝ εμπεριέχεται στο αλφάβητο
			return 0; //Επιστρέφουμε 0 και τερματίζουμε την συνάρτηση
		}
		
		return 1; //Τέλος επιστρέφουμε 1 η συμβολοσειρά εισόδου είναι σωστή
	}
